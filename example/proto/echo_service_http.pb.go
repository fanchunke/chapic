// Code generated by protoc-gen-go-chapic. DO NOT EDIT.
// versions:
// - protoc-gen-go-chapic v0.2.0
// - protoc             (unknown)
// source: proto/echo_service.proto

// Echo Service
//
// Echo Service API consists of a single service which returns
// a message.

package proto

import (
	context "context"
	fmt "fmt"
	client "github.com/fanchunke/chapic/client"
	protojson "google.golang.org/protobuf/encoding/protojson"
	http "net/http"
	url "net/url"
)

import (
	echo "github.com/labstack/echo/v4"
)

var _ = new(protojson.MarshalOptions)
var _ = new(fmt.State)
var _ = new(url.Values)

// EchoHTTPClient is the client API for Echo service.
type EchoHTTPClient interface {
	// UnaryEcho is unary echo.
	UnaryEcho(ctx context.Context, req *EchoRequest, opts ...client.Option) (*EchoResponse, error)
	// UnaryEcho is unary echo.
	UnaryEchoPost(ctx context.Context, req *EchoPostRequest, opts ...client.Option) (*EchoResponse, error)
}

type echoHTTPClient struct {
	*client.Client
}

func NewEchoHTTPClient(ctx context.Context, opts ...client.Option) EchoHTTPClient {
	c := client.NewClient(opts...)
	return &echoHTTPClient{Client: c}
}

func (c *echoHTTPClient) UnaryEcho(ctx context.Context, req *EchoRequest, opts ...client.Option) (*EchoResponse, error) {
	baseUrl, err := url.Parse(c.Client.BaseURL)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/example/%v", req.GetId())

	params := url.Values{}
	if req.GetMessage() != "" {
		params.Add("message", fmt.Sprintf("%v", req.GetMessage()))
	}

	baseUrl.RawQuery = params.Encode()

	var resp EchoResponse
	if err := client.Request[*EchoRequest, *EchoResponse](ctx, c.Client, "GET", baseUrl.String(), req, &resp, opts...); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *echoHTTPClient) UnaryEchoPost(ctx context.Context, req *EchoPostRequest, opts ...client.Option) (*EchoResponse, error) {
	baseUrl, err := url.Parse(c.Client.BaseURL)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/examples")

	var resp EchoResponse
	if err := client.Request[*EchoPostRequest, *EchoResponse](ctx, c.Client, "POST", baseUrl.String(), req, &resp, opts...); err != nil {
		return nil, err
	}
	return &resp, nil
}

// EchoHTTPServer is the server API for Echo service.
// All implementations should embed UnimplementedEcho
// for forward compatibility.
type EchoHTTPServer interface {
	// UnaryEcho is unary echo.
	UnaryEcho(ctx context.Context, req *EchoRequest) (*EchoResponse, error)
	// UnaryEcho is unary echo.
	UnaryEchoPost(ctx context.Context, req *EchoPostRequest) (*EchoResponse, error)
}

// UnimplementedEchoHTTPServer should be embedded to have forward compatible implementations.
type UnimplementedEchoHTTPServer struct {
}

func (UnimplementedEchoHTTPServer) UnaryEcho(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {
	return nil, fmt.Errorf("method UnaryEcho not implemented")
}

func (UnimplementedEchoHTTPServer) UnaryEchoPost(ctx context.Context, req *EchoPostRequest) (*EchoResponse, error) {
	return nil, fmt.Errorf("method UnaryEchoPost not implemented")
}

func RegisterEchoHTTPServer(e *echo.Echo, srv EchoHTTPServer, m ...echo.MiddlewareFunc) {
	e.GET("/v1/example/:id", _Echo_UnaryEcho_HTTPHandler(srv), m...)
	e.POST("/v1/examples", _Echo_UnaryEchoPost_HTTPHandler(srv), m...)
}

func _Echo_UnaryEcho_HTTPHandler(srv EchoHTTPServer) echo.HandlerFunc {
	return func(c echo.Context) error {
		in := new(EchoRequest)
		if err := c.Bind(in); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, echo.Map{"error": err})
		}

		resp, err := srv.UnaryEcho(c.Request().Context(), in)
		if err != nil {
			return err
		}

		return c.JSON(http.StatusOK, resp)
	}
}

func _Echo_UnaryEchoPost_HTTPHandler(srv EchoHTTPServer) echo.HandlerFunc {
	return func(c echo.Context) error {
		in := new(EchoPostRequest)
		if err := c.Bind(in); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, echo.Map{"error": err})
		}

		resp, err := srv.UnaryEchoPost(c.Request().Context(), in)
		if err != nil {
			return err
		}

		return c.JSON(http.StatusOK, resp)
	}
}
